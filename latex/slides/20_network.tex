\input{slides_template}	% nothing to do here
\input{c_advanced_info} % TODO modify this if you have not already done so

% meta-information
\newcommand{\topic}{%
    Network Programming
}

% nothing to do here
\title{\topic}
\supertitle{\course}
\date{}

% the actual document
\begin{document}

\maketitle

\begin{frame}{Contents}
	\tableofcontents
\end{frame}

\section{Network Protocols}
\subsection{}

\begin{frame}{Osi Reference Model}
    % OSI model, Pfeil auf Layer 4
\end{frame}

\begin{frame}{Transport Protocols}
    TCP:
    \begin{itemize}
        \item bissl Foo
    \end{itemize}
    UDP:
    \begin{itemize}
        \item bissl Bar
    \end{itemize}
    % vielleicht auch keine zwei itemize, sondern was schöneres
\end{frame}

\section{Socket Programming}
\subsection{}

\begin{frame}[fragile]{Sockets}
    Sockets are abstractions for connection endpoints to be used by processes.
    Both the server and the client process have a socket which they use to
    send data to each other.\\
    \bigskip
    Sockets are platform-dependend, but the system call interface is similar:
    \begin{description}
        \item[Unix] file descriptors (\lstinline{int})
        \item[Windows] handles for kernel objects
            (\lstinline[morekeywords={*,SOCKET}]{SOCKET})
    \end{description}
    \bigskip
    You will also have to include different headers:
    \begin{lstlisting}[numbers=none]
// Unix
#include <sys/socket.h>
// Windows
#include <windows.h>
\end{lstlisting}
    % Unix: files (int - file descriptor), Windows: objects (SOCKET - handle)
    % und die beiden Header
\end{frame}

% Dann noch jeweils ein Frame zu folgenden Funktionen mit kurzer Erklärung
% sowie Windows- und Unix-Prototyp
% Dabei die Argumente und einsetzbaren Konstanten erklären
% - socket()
% -- hier evtl. noch ein Frame mit Erklärung der Netzwerkadressrechnung
% - close[socket]()

\begin{frame}[fragile]{\texttt{connect()}}
    Connect a socket to another via the network.
    \begin{lstlisting}[numbers=none,morekeywords={*,SOCKET,socklen_t,sockaddr}]
// Unix
int connect(int socket, const struct sockaddr *address,
         socklen_t address_len);
// Windows
int connect(SOCKET socket, const struct sockaddr *address,
         int address_len);
\end{lstlisting}
    \begin{description}
        \item[socket] Socket to be connected
        \item[address] Structure containing target IP address and port
        \item[address\_len] Size of *address in memory
        \item[return value] Exit status (0 = success, -1 = failure)
    \end{description}
    \bigskip
    UDP sockets don't establish a connection $\rightarrow$ \texttt{connect()} is
    optional.
\end{frame}

\begin{frame}[fragile]{\texttt{bind()}}
    Bind an address to a socket.
    \begin{lstlisting}[numbers=none,morekeywords={*,SOCKET,socklen_t,sockaddr}]
// Unix
int bind(int socket, const struct sockaddr *address,
         socklen_t address_len);
// Windows
int bind(SOCKET socket, const struct sockaddr *address,
         int address_len);
\end{lstlisting}
    \begin{description}
        \item[socket] Socket to be bound
        \item[address] Structure containing IP address and port
        \item[address\_len] Size of *address in memory
        \item[return value] Exit status (0 = success, -1 = failure)
    \end{description}
    \bigskip
    Naming a socket is necessary for connections from the outside!
\end{frame}

\begin{frame}[fragile]{\texttt{listen()}}
    Enable listening for connections to a specific socket.
    \begin{lstlisting}[numbers=none,morekeywords={*,SOCKET}]
// Unix
int listen(int socket, int backlog);
// Windows
int listen(SOCKET socket, int backlog);
\end{lstlisting}
    \begin{description}
        \item[socket] Socket to put into listening mode
        \item[backlog] Hint for an upper bound of the number of outstanding
            connections in the listening queue of the socket
        \item[return value] Exit status (0 = success, -1 = failure)
    \end{description}
    \bigskip
    Calling \texttt{listen()} on a socket is necessary to accept incoming TCP
    connections on a server.
\end{frame}

\begin{frame}[fragile]{\texttt{accept()}}
    Accept a new connection on a socket.
    \begin{lstlisting}[numbers=none,morekeywords={*,SOCKET,sockaddr,socklen_t}]
// Unix
int accept(int socket, struct sockaddr *restrict address,
           socklen_t *restrict address_len);
// Windows
SOCKET accept(SOCKET socket, struct sockaddr *address,
              int *address_len);
\end{lstlisting}
    \begin{description}
        \item[socket] Listening socket
        \item[address] Where to store the address of the
            connecting socket
        \item[address\_len] Size of *address in memory
        \item[return value] Socket for the new connection on success, invalid
            descriptor otherwise
    \end{description}
    \bigskip
    By default, \texttt{accept()} blocks if the socket's connection queue is empty!
\end{frame}

% - send() / recv() / sendto() / recvfrom()}

% nothing to do from here on
\end{document}
